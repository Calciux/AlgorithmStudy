[TOC]
## 0-1背包问题
有 N 件物品和一个容量为 M 的背包。第 i 件物品的重量是 W i ​ ，价值是 D i ​ 。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。
```C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    vector<int> W(N + 1), D(N + 1);
    for (int i = 1; i <= N; ++i) {
        cin >> W[i] >> D[i];
    }

    vector<int> dp(M + 1, 0);
    for (int i = 1; i <= N; ++i) {
        for (int j = M; j >= W[i]; --j) {
            dp[j] = max(dp[j], dp[j - W[i]] + D[i]);
        }
    }

    cout << dp[M] << endl;
    return 0;
}

```
## 完全背包
 ```C++
 #include <bits/stdc++.h>

using namespace std;

int main()
{
    int m; // 物品数目
    int t; // 总时间/背包容量
    cin >> t >> m;
    vector<int> T(m + 1), V(m + 1); // 物品时间/价值
    for (int i = 1; i <= m; i++)
    {
        cin >> T[i] >> V[i];
    }
    vector<long long> dp(t + 1, 0);
    for (int i = 1; i <= m; i++)
    {
        for (int j = T[i]; j <= t; j++)
        {
            dp[j] = max(dp[j], dp[j - T[i]] + V[i]);
        }
    }
    cout << dp[t];
    return 0;
}
 
 ```

 ## 多重背包
 ```C++
 int main()
{
    int n; // 物品种类
    int W; // 容量
    cin >> n >> W;
    vector<int> val(1000005), weight(1000005);
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = 1;j<=c;j<<=1){
            val[++cnt] = j * a;
            weight[cnt] = j * b;
            c -= j;
        }
        if(c>0){
            val[++cnt] = a * c;
            weight[cnt] = b * c;
        }
    }
    vector<long long> dp(W + 1, 0);
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = W; j >= weight[i];j--){
            dp[j] = max(dp[j], dp[j - weight[i]] + val[i]);
        }
    }
    cout<<dp[W]<<endl;
    return 0;
}
 ```

 ## 分组背包问题
 ```C++
 #include <bits/stdc++.h>

using namespace std;

int main(){
    int m, n;//n物品,总质量m
    cin >> m >> n;
    unordered_map<int,vector<pair<int,int>>> groups;
    for (int i = 1; i <= n;i++){
        int w,v,g;
        cin >> w >> v >> g;
        groups[g].emplace_back(w, v);
    }
    vector<long long> dp(m + 1, 0);
    for(auto &grp:groups){
        auto &items = grp.second;
        for (int j = m; j >= 0;j--){
            for(auto &it:items){
                int w = it.first;
                int v = it.second;
                if(j>=w){
                    dp[j] = max(dp[j], dp[j - w] + v);
                }
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}```